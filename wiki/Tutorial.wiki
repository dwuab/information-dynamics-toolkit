#summary A brief tutorial for how to use JIDT

The tutorial slides are currently being written and will be posted here shortly.

The tutorial also contains an exercise.

= Slides =

Coming soon.

The slides will introduce the information-theoretic measures, then briefly introduce the toolkit, and walk through some of the demos.

= Excercise =

To consolidate your understanding of the toolkit, you will complete a task of applying one of the calculators to one of the sample data sets to create some new insights.

== 1. Compute MI in heart-breath interaction ==

The demonstration set SchreiberTeDemos uses our toolkit to recreate Schreiber's original transfer entropy analysis of information flow between heart and breath rate, and then adds some further insights using our KSG (Kraskov et al.) Transfer Entropy and Active Information Storage calculators.

Your exercise task is to:
 # Compute the Mutual Information between the heart and breath rate for this data set (using samples 2350 to 3550, inclusive);
 # Using KSG Mutual Information estimator (say with KSG algorithm 2) with 4 nearest neighbours.

You can either:
 # write code for this from scratch in your preferred environment (the data set is at [http://code.google.com/p/information-dynamics-toolkit/source/browse/#svn%2Ftrunk%2Fdemos%2Fdata%2FSFI-heartRate_breathVol_bloodOx.txt demos/data/SFI-heartRate_breathVol_bloodOx.txt]), or
 # you can start by using one of our sample scripts which calculate Transfer Entropy on this data set as a template. These samples include code to read in the data and parse the arguments. There are samples available for Transfer Entropy here in either:
  # Java ([http://code.google.com/p/information-dynamics-toolkit/source/browse/#svn%2Ftrunk%2Fdemos%2Fjava%2Finfodynamics%2Fdemos%2FschreiberTransferEntropyExamples/HeartBreathRateKraskovRunner.java demos/java/infodynamics/demos/schreiberTransferEntropyExamples/HeartBreathRateKraskovRunner.java]) or
  # Octave ([http://code.google.com/p/information-dynamics-toolkit/source/browse/#svn%2Ftrunk%2Fdemos%2Foctave%2FSchreiberTransferEntropyExamples/runHeartBreathRateKraskov.m demos/octave/SchreiberTransferEntropyExamples/runHeartBreathRateKraskov.m]) or
  # Python ([http://code.google.com/p/information-dynamics-toolkit/source/browse/#svn%2Ftrunk%2Fdemos%2Fpython%2FSchreiberTransferEntropyExamples/runHeartBreathRateKraskov.py demos/python/SchreiberTransferEntropyExamples/runHeartBreathRateKraskov.py]).

*Answer: 0.123 nats.*

*HINT* -- If you're getting stuck, start with one of our sample TE scripts as above, and try to read through and understand how it is working first.
Next, remember that in using any of the calculators, you should follow the following steps:
 # Construct the calculator -- which class should you be using to achieve this calculation? (Remember we want MI, by KSG estimator, algorithm 2)
 # Initialise the calculator -- what parameters should be supplied here? (Check the [Documentation Javadocs] for this class)
 # Set relevant properties for the calculator -- what properties are available? (Check the [Documentation Javadocs] for this class)
 # Supply the data to the calculator using a `set/addObservations()` method
 # Calculate the average MI.

== 2. Challenge 1. Compute MI over various lags ==

Extend your code from the above task to compute the Mutual Information between heart rate and breath rate, for a variety of lags between the two time-series. For instance, investigate lags of (0, 1, ..., 14, 15).

*HINT*: You could either shift the time-series with respect to eachother to affect the lag, or a cleaner method can be achieved if you investigate the available properties for this MI calculator in the [Documentation Javadocs] (_Challenge_: what to do if you want to use negative lags, i.e. a positive lag from breath to heart, with this property?)

Sample results:

[http://information-dynamics-toolkit.googlecode.com/svn/trunk/demos/octave/SchreiberTransferEntropyExamples/sampleResults/heartBreathResults-kraskovMI.png] 

What would you interpret from the results? Can you think of some logical further investigations here?

== 3. Challenge 2. Compute Local TE as a function of past breath rate ==

This challenge task is best achieved in Matlab/Octave, since it involves plotting the results.

Return to computing transfer entropy for heart to breath rate (using a KSG estimator, k=4 nearest neighbours) -- you can either write this from scratch or return to the demo code available as indicated above.
 # Compute the time-series of *local* TE here (*HINT*: see [SimpleJavaExamples#Example_4_-_Transfer_entropy_on_continuous_data_using_Kraskov_es Simple demo 4] if you're not sure how to do that)
 # Plot these local TE values as a function of the previous breath rate. Investigate both k and l=1 and k and l=2 for history embedding lengths here. This is inspired by Figure 4 in [http://arxiv.org/abs/1102.1507 arXiv:1102.1507]; the result will not be identical, since we are using a different estimator and our fully localised values will give a resulting scatter plots (rather than the somewhat smoothed results there due to partially local values). Further we use potentially different embedding lengths.