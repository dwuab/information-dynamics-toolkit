#summary Frequently asked questions about the toolkit

On this page, we list several frequently asked questions about the toolkit (these are mostly excerpts from emails):
 * [#What_do_I_do_about_java.lang.OutOfMemoryError? What do I do about java.lang.OutOfMemoryError?]
 * [#How_can_I_build_JIDT_from_the_latest_SVN_sources? How can I build JIDT from the latest SVN sources?]
 * [#How_fast_is_the_toolkit,_e.g._for_transfer_entropy_estimation? How fast is the toolkit, e.g. for transfer entropy estimation?]
 * [#Can_the_Kraskov-Stoegbauer-Grassberger_estimator_add_noise_to_the_data? Can the Kraskov-Stoegbauer-Grassberger estimator add noise to the data?]

== What do I do about `java.lang.OutOfMemoryError`? ==

Getting `java.lang.OutOfMemoryError` errors means that the heap space allocated to your JVM instance is not large enough for your program.

If you are running Java directly, then you can increase the maximum heap space by adding an argument to the `java` command such as `-Xmx512M` to request 512 MB heap space, for example.

When running Java from other environments, e.g. in an IDE, in Matlab, GNU Octave, Python etc, you will need to specify this parameter in a manner dependent on that environment:
 * Matlab often gives this error because the heap space is usually set to a rather low value. Increasing the heap space allocated by Matlab to the JVM is described e.g. [http://www.mathworks.com.au/help/matlab/matlab_env/preferences.html#bsemees-1 here].
 * For Python via JPype, you can specify this parameter when calling the `startJVM()` function; see comments in the PythonExamples.
 * For Julia, you can specify this parameter when calling the `JavaCall.init()` method; see comments in the JuliaExamples.

== How can I build JIDT from the latest SVN sources? ==

If you need one of the latest features that are only available via SVN (or you want to grab the source code and make some changes), you can grab the source and build `infodynamics.jar` as follows:

1. Make an SVN checkout, e.g.:
{{{
svn checkout http://information-dynamics-toolkit.googlecode.com/svn/trunk/ information-dynamics-toolkit-read-only
}}}
or update an existing SVN checkout:
{{{
svn update
}}}
2. Compile the code and build your own `infodynamics.jar`:
{{{
ant jar
}}}

== How fast is the toolkit, e.g. for transfer entropy estimation? ==

I've had some enquiries regarding how long the toolkit will take to compute transfer entropy on large data sets, say 100 000 samples.
The answer depends mostly on the type of data that you are calculating transfer entropy on:
 # *Is it discrete or discretized data?* [http://code.google.com/p/information-dynamics-toolkit/source/browse/trunk/java/source/infodynamics/measures/discrete/ApparentTransferEntropyCalculator.java infodynamics.discrete.ApparentTransferEntropyCalculator] is very fast, on the order of 1 sec or less for this sized data.
 # *Is it continuous data (that you would prefer not to discretize)?* This is generally slower, using techniques such as a Kraskov-Grassberger estimator (this is the best of breed for continuous valued data), i.e. [http://code.google.com/p/information-dynamics-toolkit/source/browse/trunk/java/source/infodynamics/measures/continuous/kraskov/TransferEntropyCalculatorKraskov.java infodynamics.measures.continuous.kraskov.TransferEntropyCalculatorKraskov], but not too far behind. At v1.0, a 100 000 time step calculation would take almost an hour with this estimator; however with the recent implementation of a fast-neighbour search algorithm (available in the SVN and from v1.1 onwards) this has dropped to (sub?) seconds. If you want the calculation to run faster than that, then you could discretize your data (at the expense of accuracy), or subsample (say into 10 data sets of 10 000 time steps, and average over these. This will be a little less accurate, but you will get a standard error measurement from this approach as well). You can test out how long the code takes to run e.g. with [SimpleJavaExamples#Example_4_-_Transfer_entropy_on_continuous_data_using_Kraskov_es example4] in the simple java demos (mirrored in the simple octave/matlab demos [OctaveMatlabExamples#Example_4_-_Transfer_entropy_on_continuous_data_using_Kraskov_es here] and the python demos [PythonExamples#Example_4_-_Transfer_entropy_on_continuous_data_using_Kraskov_es here]), by altering the length of the random data that is used.

== Can the Kraskov-Stoegbauer-Grassberger estimator add noise to the data? ==

The [http://dx.doi.org/10.1103/PhysRevE.69.066138 original publication] of the KSG estimator recommends the addition of a very small amount of noise to the data (e.g 1e-8) to address the situation where multiple data points share the same value in (at least) one dimension.

This can be done for each KSG estimator in JIDT (for MI basec calculators from v1.0, for conditional MI based calculators from v1.1) as shown below for the transfer entropy estimator:
{{{
// The following is Java code; change it to your own language if required
TransferEntropyCalculatorKraskov teCalc =
		new TransferEntropyCalculatorKraskov();
teCalc.setProperty("NORMALISE", "true"); // Normalise the individual variables (default)
// Set up to add noise with standard deviation of 0.00000001 normalised units
teCalc.setProperty("NOISE_LEVEL_TO_ADD", "0.00000001");
// Then use the calculator as normal ...
}}}
More details are shown in the [Documentation Javadocs] for the `setProperty(String, String)` method for each relevant calculator.