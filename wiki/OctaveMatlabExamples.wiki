#summary Examples of using the toolkit in Octave or Matlab
#labels octave,matlab,Phase-Deploy,examples

= Octave/Matlab code examples =

These examples are designed for Octave, but to run the following in Matlab, convert the `javaObject()` calls to `javaObjectEDT()` and they *should* work, though I haven't tested them.

This page contains the following code examples:
  * [#Example_1_-_Transfer_entropy_on_binary_data 1 - Transfer entropy on binary data]
  * [#Example_2_-_Transfer_entropy_on_multidimensional_binary_data 1 - Transfer entropy on multidimensional binary data]
  * [#Example_3_-_Transfer_entropy_on_continuous_data_using_Kraskov_estimators 3 - Transfer entropy on continuous data using Kraskov estimators]

= Example 1 - Transfer entropy on binary data =

Simple transfer entropy (TE) calculation on binary data using the discrete TE calculator:

{{{
javaaddpath('infoDynamics.jar');

% Generate some random binary data.
% Note that we need the *1 to make this a number not a Boolean,
%  otherwise this will not work (as it cannot match the method signature)
sourceArray=(rand(100,1)>0.5)*1; 
destArray = [0; sourceArray(1:99)];
sourceArray2=(rand(100,1)>0.5)*1;
% Create a TE calculator and run it:
teCalc=javaObject('infodynamics.measures.discrete.ApparentTransferEntropyCalculator', 2, 1);
teCalc.initialise();
teCalc.addObservations(destArray, sourceArray);
% For copied source, should give something close to 1 bit:
result = teCalc.computeAverageLocalOfObservations()
teCalc.initialise();
teCalc.addObservations(destArray, sourceArray2);
% For random source, it should give something close to 0 bits
result2 = teCalc.computeAverageLocalOfObservations()
}}}

= Example 2 - Transfer entropy on multidimensional binary data =

Simple transfer entropy (TE) calculation on multidimensional binary data using the discrete TE calculator.

This example is important for Octave users, because it shows how to handle multidimensional arrays from Octave to Java (this is not as simple as single dimensional arrays in example 1 - it requires assigning every element individually, and creating a double[][] array first and then converting to int[][]).

{{{
javaaddpath('infoDynamics.jar');

% Things get a little tricky if we want to pass 2D arrays in.
% Unlike native Octave 1D arrays above, 
%  native Octave 2D+ arrays do not seem to get directly converted to java arrays,
%  so we need to copy every part of the array individually:
numColumns = 100;
twoDTimeSeries = javaArray('java.lang.Double',2,numColumns);
for c = 1:numColumns
    twoDTimeSeries(1,c) = (rand()>0.5)*1;
end
for c = 1:numColumns
    % Copy the value of the source to the left from the previous time step
    twoDTimeSeries(2,c) = twoDTimeSeries(1,mod(c-2,numColumns)+1);
end
% Assigning native Octave values directly to a java.lang.Integer array does not
%  work either, so we created a Double array above, and then convert it to 
%  an int array here:
mUtils = javaObject('infodynamics.utils.MatrixUtils');
twoDTimeSeries = mUtils.doubleToIntArray(twoDTimeSeries);
teCalc.initialise();
teCalc.addObservations(twoDTimeSeries, 1);
% The result should be close to 1 bit here, since we are executing copy operations 
%  of what is effectively a random bit to each cell here:
result2D = teCalc.computeAverageLocalOfObservations()
}}}

= Example 3 - Transfer entropy on continuous data using Kraskov estimators =

Simple transfer entropy (TE) calculation on continuous-valued data using the Kraskov-estimator TE calculator.

{{{
javaaddpath('infoDynamics.jar');

% Generate some random normalised data.
numObservations = 1000;
covariance=0.4;
sourceArray=normrnd(0, 1, numObservations, 1);
destArray = [0; covariance*sourceArray(1:numObservations-1) + (1-covariance)*normrnd(0, 1, numObservations - 1, 1)];
sourceArray2=normrnd(0, 1, numObservations, 1); % Uncorrelated source
% Create a TE calculator and run it:
teCalc=javaObject('infodynamics.measures.continuous.kraskov.TransferEntropyCalculatorKraskov');
teCalc.initialise(1); % Use history length 1 (Schreiber k=1)
teCalc.setProperty("k", "4"); % Use Kraskov parameter K=4 for 4 nearest points
% Perform calculation with correlated source:
teCalc.setObservations(sourceArray, destArray);
result = teCalc.computeAverageLocalOfObservations();
% Note that the calculation is a random variable (because the generated
%  data is a set of random variables) - the result will be of the order
%  of what we expect, but not exactly equal to it; in fact, there will
%  be a large variance around it.
printf("TE result %.4f nats; expected to be close to %.4f nats for these correlated Gaussians\n", \
    result, log(1/(1-covariance^2)));
% Perform calculation with uncorrelated source:
teCalc.initialise(); % Initialise leaving the parameters the same
teCalc.setObservations(sourceArray2, destArray);
result2 = teCalc.computeAverageLocalOfObservations();
printf("TE result %.4f nats; expected to be close to 0 nats for these uncorrelated Gaussians\n", result2);
}}}